#!/usr/bin/env python3
import os
import sys
import logging
import requests
import argparse
import requests.exceptions
from dotenv import load_dotenv
from colorama import Fore, Style, init
from concurrent.futures import ThreadPoolExecutor

load_dotenv()
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
init(autoreset=True)


def file_exists(file_path):
    # Check if a file exists and exit if it does not
    if not os.path.exists(file_path):
        print(f'Error: The file {file_path} does not exist.')
        sys.exit(1)


def read_headers(file_path):
    # Read headers from a file and return a dictionary
    headers = {}
    with open(file_path, 'r') as file:
        for line in file:
            if ': ' in line:
                key, value = line.strip().split(': ', 1)
                headers[key] = value
            else:
                print(f'Skipping header line: {line.strip()}')
    return headers


def get_proxy_config(use_proxy):
    if use_proxy:
        http_proxy = os.getenv('HTTP_PROXY')
        https_proxy = os.getenv('HTTPS_PROXY')
        if http_proxy or https_proxy:
            print(f'Using proxy {http_proxy} -- {https_proxy}')
        else:
            print('Proxy is enabled but no proxies are set in the environment.')
        return {'http': http_proxy, 'https': https_proxy}
    else:
        # Desabilita o uso de proxy limpando as variáveis de ambiente
        os.environ.pop('HTTP_PROXY', None)
        os.environ.pop('HTTPS_PROXY', None)
        os.environ.pop('http_proxy', None)  # Algumas vezes também são usadas em minúsculas
        os.environ.pop('https_proxy', None)
        print('Not using proxy')
        return {}


def fuzz_request(url, headers, proxy, cert_path, verify, value, filter_size):
    options = {'headers': headers, 'cert': cert_path, 'verify': verify}
    if proxy:
        options['proxies'] = proxy
    
    try:
        current_url = url.replace('BRUTE', value)
        response = requests.get(current_url, headers=headers, proxies=proxy, cert=cert_path, verify=verify)
        response_size = len(response.content)

        if filter_size and response_size == filter_size:
            return
        if 200 <= response.status_code < 300:
            code_color = Fore.GREEN
        elif 300 <= response.status_code < 400:
            code_color = Fore.YELLOW
        else:
            code_color = Fore.RED

        logging.info(f'{Fore.MAGENTA}Value: {value} {code_color}[{response.status_code}] - {Fore.CYAN}Response Text: {response.text} {Fore.MAGENTA}Size: {response_size}{Style.RESET_ALL}')
    except requests.exceptions.RequestException as e:
        logging.error(f'Failed to make request for value {value}: {e}')

def fuzzing_tool(url, headers, proxy, cert_path, verify, values, filter_size, threads):
    with ThreadPoolExecutor(max_workers=threads) as executor:
        # Pass each value to fuzz_request
        executor.map(lambda value: fuzz_request(url, headers, proxy, cert_path, verify, value, filter_size), values)


def main():
    parser = argparse.ArgumentParser(description='Fuzzing tool based on HTTP requests.')
    parser.add_argument('url', type=str, help='The target URL with "BRUTE" as the placeholder for injection points.')
    parser.add_argument('-H', '--headers', type=str, help='Path to the headers file.')
    parser.add_argument('-w', '--wordlist', type=str, help='Path to the wordlist file.')
    parser.add_argument('--range', type=str, help='Range of numbers to use, format start-end,digits (e.g., 001-100,3).')
    parser.add_argument('--ssl', type=str, help='Path to the SSL certificate file.')
    parser.add_argument('--use-proxy', action='store_true', help='Enable proxy configuration from .env file')
    parser.add_argument('-fs', type=int, help='Filer responses by size (skip responses with this size.')
    parser.add_argument('-t', '--threads', type=int, default=10, help='Number of threads to use for fuzzing.')

    args = parser.parse_args()
    proxy = get_proxy_config(args.use_proxy)
    headers = read_headers(args.headers) if args.headers else {}
    cert_path = args.ssl
    verify = cert_path

    values = []
    if args.wordlist:
        file_exists(args.wordlist)
        with open(args.wordlist, 'r') as file:
            values = [line.strip() for line in file]
    if args.range:
        range_part, *digits_part = args.range.split(',')
        start, end = map(int, range_part.split('-'))
        digits = int(digits_part[0]) if digits_part else 3
        values = [f'{i:0{digits}}' for i in range(start, end+1)]
    if not values:
        print('Error: No Values provided for fuzzing.')
        sys.exit(1)

    try:
        fuzzing_tool(args.url, headers, proxy, cert_path, verify, values, args.fs, args.threads)
    except KeyboardInterrupt:
        print('\nFuzzing interrupted by user.')
        sys.exit(0)
    except Exception as e:
        print(f'Unexpected error: {e}')
        sys.exit(1)


if __name__ == '__main__':
    main()
