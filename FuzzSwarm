#!/usr/bin/env python3
import os
import sys
import logging
import requests
import argparse
import requests.exceptions
from dotenv import load_dotenv

load_dotenv()
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] - Value: %(message)s', datefmt='%Y-%m-%d %H:%M:%S')


def file_exists(file_path):
    # Check if a file exists and exit if it does not
    if not os.path.exists(file_path):
        print(f'Error: The file {file_path} does not exist.')
        sys.exit(1)


def read_headers(file_path):
    # Read headers from a file and return a dictionary
    headers = {}
    with open(file_path, 'r') as file:
        for line in file:
            if ': ' in line:
                key, value = line.strip().split(': ', 1)
                headers[key] = value
            else:
                print(f'Skipping header line: {line.strip()}')
    return headers


def get_proxy_config(use_proxy):
    if use_proxy:
        http_proxy = os.getenv('HTTP_PROXY')
        https_proxy = os.getenv('HTTPS_PROXY')
        print(f'Using proxy {http_proxy} -- {https_proxy}')
        return {'http': http_proxy, 'https': https_proxy}
    else:
        print('Not using proxy')
        return {}


def fuzzing_tool(url, headers, proxy, cert_path, verify, values, filter_size):
    # Perform fuzzing requests with given parameters
    for value in values:
        try:
            current_url = url.replace('BRUTE', value)
            response = requests.get(current_url, headers=headers, proxies=proxy, cert=cert_path, verify=verify)
            response_size = len(response.content)

            if filter_size and response_size == filter_size:
                continue

            #logging.info(f'Value: {value} Response Code: {response.status_code} Response Text: {response.text} Response Size: {response_size}')
            logging.info(f'{value} [{response.status_code}] - Response Text: {response.text} Size: {response_size}')
        except requests.exceptions.RequestException as e:
            logging.error(f'Failed to make request for value {value}: {e}')


def main():
    parser = argparse.ArgumentParser(description='Fuzzing tool based on HTTP requests.')
    parser.add_argument('url', type=str, help='The target URL with "BRUTE" as the placeholder for injection points.')
    parser.add_argument('-H', '--headers', type=str, help='Path to the headers file.')
    parser.add_argument('-w', '--wordlist', type=str, help='Path to the wordlist file.')
    parser.add_argument('--range', type=str, help='Range of numbers to use, format start-end,digits (e.g., 001-100,3).')
    parser.add_argument('--ssl', type=str, help='Path to the SSL certificate file.')
    parser.add_argument('--use-proxy', action='store_true', help='Enable proxy configuration from .env file')
    parser.add_argument('-fs', type=int, help='Filer responses by size (skip responses with this size.')

    args = parser.parse_args()
    proxy = get_proxy_config(args.use_proxy)
    headers = read_headers(args.headers) if args.headers else {}
    cert_path = args.ssl
    verify = cert_path

    values = []
    if args.wordlist:
        file_exists(args.wordlist)
        with open(args.wordlist, 'r') as file:
            values = [line.strip() for line in file]
    if args.range:
        range_part, *digits_part = args.range.split(',')
        start, end = map(int, range_part.split('-'))
        digits = int(digits_part[0]) if digits_part else 3
        values = [f'{i:0{digits}}' for i in range(start, end+1)]
    if not values:
        print('Error: No Values provided for fuzzing.')
        sys.exit(1)

    try:
        fuzzing_tool(args.url, headers, proxy, cert_path, verify, values, args.fs)
    except KeyboardInterrupt:
        print('\nFuzzing interrupted by user.')
        sys.exit(0)
    except Exception as e:
        print(f'Unexpected error: {e}')
        sys.exit(1)


if __name__ == '__main__':
    main()

